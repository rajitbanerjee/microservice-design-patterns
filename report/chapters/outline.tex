\chapter{Outline of Approach}

In order to demonstrate various performance engineering practices in the context of microservice design patterns, we look at a simple movie ticket reservation system, consisting of 3 independent cinemas (Cineworld, Dundrum and UCD), as well as an intermediary (or broker) between clients and the cinema services. Each cinema has its own catalogue of movies (with an ID, name, and available showtimes). The client's primary objective would be to request the intermediary to fetch a list of movies from every active cinema, then display aggregated results. Next, the client selects a movie and showtime (along with other booking details) to make a reservation at a specific cinema. It is also possible to list the reservations made at a given cinema (useful for staff and administrators). The intermediary serves as a router for client requests to the cinema services, and in some cases, an aggregator of results.


\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\linewidth]{./assets/diagrams/outline-arch.png}
  \caption{Prototype of movie ticket reservation system using microservices.}
  \label{fig:outline-arch}
\end{figure}


In this project, two separate web applications have been designed to model the same system described above, each employing a variety of common design patterns. The applications follow microservice architecture, with the intermediary and cinema services all being self-contained, loosely-coupled and independently deployable. Taking each application to be a \textit{case study}, the next chapter provides descriptions of the system design, implementation specifics, design pattern choices, and the associated performance implications. In a larger scale production system, it is likely that each independent cinema would in turn comprise a number of microservices to serve more specific purposes, but to avoid over-complicating the architecture in this project, cinemas are designed to be single entities.

One of the main benefits of microservices is the freedom of choice regarding the programming language used for development, since any suitable language may be used as long the service exposes an API \footnote{\url{https://www.mulesoft.com/resources/api/what-is-an-api}} adhering to known standards (typically HTTP \footnote{\url{https://developer.mozilla.org/en-US/docs/Web/HTTP}} and REST \footnote{\url{https://en.wikipedia.org/wiki/Representational_state_transfer}}). The API is then used for inter-service communication. For the case studies in this project, Java and Spring \footnote{\url{https://spring.io}} are chosen over other languages and frameworks primarily due to the dominance of Java in enterprise-level software, as well as the feature richness of Spring. Moreover, as shown in a 2017 study by Pereira et al. \cite{pereira17}, Java ranks much higher in terms of time, memory and energy efficiency; which need to be considered when talking about system performance; compared to other popular languages such as Python or TypeScript/JavaScript. The Spring framework in Java offers a plethora of integrations and abstractions to implement microservice and cloud-related design patterns, through projects such as Spring Boot, Spring Data, Spring Cloud and Spring AMQP, to name a few that are used in the case study web applications here. Apache Maven \footnote{\url{https://maven.apache.org}} is the tool used for dependency management for Java.

Each web application exposes APIs for its microservices, whose endpoints can be invoked with HTTP requests like GET and POST. In commercial systems, a website (UI client) would invoke the backend API to perform actions, but for our case studies, it is sufficient to use a tool such as Postman \footnote{\url{https://www.postman.com}} or VS Code's REST Client \footnote{\url{https://marketplace.visualstudio.com/items?itemName=humao.rest-client}} to demonstrate the API functionalities locally.

In line with industry standards, Docker \footnote{\url{https://www.docker.com}} is the infrastructure/containerisation tool used to deploy the fleet of microservices. According to Docker, Inc., a \textit{container image} is a lightweight, standalone, executable package of software that includes everything needed to run an application: code, runtime, system tools, system libraries and settings. Using Docker provides a number of advantages such as ease of standardisation, compatibility, maintainability, CI/CD, resource and application isolation, and much more. Container deployment and application testing is performed on an Ubuntu 18.04 LTS compute server (\textit{dunnion}, maintained by the UCD School of Computer Science \footnote{\url{https://www.ucd.ie/cs/}}), with a 10 core Intel(R) Xeon(R) Silver 4114 CPU (base frequency: 2.20 GHz), and 125GB system memory.

\textbf{TODO paras on performance testing/benchmarking}